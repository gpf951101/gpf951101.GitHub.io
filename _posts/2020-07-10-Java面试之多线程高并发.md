---
layout: article
title: Java面试之多线程高并发
key: Cyber20200710_1
date: 2020-7-10
tags: [Java, JUC, 面试]
sharing: true
show_author_profile: true
lang: zh
comment: true
pageview: true
---

尚硅谷高并发视频学习总结<br>

<!--more-->

	# 1. 谈谈对volatile的理解

## 1.1 volatile是java虚拟机提供的轻量级的同步机制

	- 保证可见性
	- 不保证原子性
	- 禁止指令重排

## 1.2 JMM（Java内存模型 Java Memory Model）

​	本身是一种抽象的概念，**不是真是存在的**。描述的是一组规则或规范，通过规范制定了程序中各个变量（包括 实例字段、静态字段和构成数组对象的元素）的访问方式。

### JMM同步规范：

- 线程解锁前，必须把共享变量的值刷回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存中
- 加锁解锁必须是同一把锁

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（栈空间），工作内存是每个线程的私有数据区域，而JMM规定所有变量都存储在**主内存**中。主内存是共享内存区域，所有线程都可以访问，但是**线程对于变量的操作（读写等）必须在工作内存中进行，所以首先要从主内存将变量拷贝到自己的工作内存，然后对变量进行操作后再协会主内存**，不能直接操作主内存中的变量，各个线程中的工作内存存储着主内存中的变量副本拷贝，因此不同线程无法访问对方的工作内存，线程中的通讯传值必须通过主内存完成。具体访问过程可见下图。

![image-20200710202346774](F:\MyBlog\gpf951101.GitHub.io\images\image-20200710202346774.png)



### 1.2.1 可见性

各个线程对于主内存中共享变量的操作都是各个线程拷贝到自己工作内存操作之后再协会主内存的，可能存在线程A修改了共享变量X的值还没有写回主内存，另外一个线程B对内存X进行了操作，但是A线程工作内存中的共享变量X对于线程B来说，并不可见。**工作内存与主内存同步延迟现象造成了可见性问题**。

#### volatile如何保证可见性？

1. Lock前缀指令会引起处理器缓存写到内存

   当对volatile变量进行操作的时候，JVM会向处理器发送一条lock前缀的指令，将缓存中的变量写回到主内存。

2. 一个处理器的缓存写回到主内存会导致其他处理器的缓存失效

   处理器使用嗅探技术保证内部缓存、主内存和其他处理器的缓存再总线上保持一致。

### 1.2.2 不保证原子性

如number++操作时被拆成3个指令的：

	- 取值
	- 操作
	- 写入

当线程A从主内存取得number之后，线程A阻塞，线程B也从主内存取得number，之后进行操作再写入。A线程阻塞结束之后，在未改变的基础上对number进行操作，原子性失效。

#### 如何保证原子性

- 使用锁Lock

- 使用Synchronized

- 使用AtomicInteger、AtomicReference等JUC提供

  - 通过`import sun.misc.Unsafe`该类实现。

  - 注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务

  - CAS是一条CPU并发原语

  - ```java
    public final int getAndAddInt(Object var1, long var2, int var4) {
            int var5;
            do {
                var5 = this.getIntVolatile(var1, var2); // 对象var1偏移量var2取值
            } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); //CSA cpmpare And Swap 比较并交换 比较是否变化，无变化进行var5+var4操作
    
            return var5;
        }
    ```

### 1.2.3 禁止指令重排

计算机在执行程序时，为了提高性能，编译器和处理器常常会做指令重排，一般分为以下三种：

![image-20200710221303593](F:\MyBlog\gpf951101.GitHub.io\images\image-20200710221303593.png)

单线程环境里面确保程序最终执行结果和代码顺序执行的结果一直。

处理器在进行重新排序的时候必须要考虑指令之间的**数据依赖性**。

多线程环境下线程交替执行，由于编译器优化重排的存在，两个线程使用的变量能否保持一致性时无法确定的，结果无法预测。

#### volatile如何禁止指令重排

内存屏障（内存栅栏 Memory Barrier）：是一个CPU指令，作用又两个：

	- 保证特定操作的执行顺序
	- 保证某些变量的内存可见性(利用该特性实现volatile的内存可见性)

由于编译器和处理器都能执行指令重排优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier执行重排，也就是说 **通过插入内存屏障禁止在内存屏障前后的执行执行重排优化**。内存屏障的另外一个作用时强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。

![image-20200711071248961](F:\MyBlog\gpf951101.GitHub.io\images\image-20200711071248961.png)

- 在每个volatile写操作的前面插入一个StoreStore屏障，保证volatile写操作前面的Store Buffer队列中的操作都已经刷新到缓存中，防止前面的写操作与volatile写操作发生指令重排。
- 在每个volatile写操作的后面插入一个StoreLoad屏障，保证后面的其他写/读操作前面的Store Buffer队列中的操作都已经刷新到缓存中（也就是volatile写操作），防止后面的其他写/读操作与volatile写操作发生指令重排。
- 在每个volatile读操作的前面插入一个LoadLoad屏障，保证后面的其他读操作的无效化队列已经将volatile无效刷新到缓存中，防止后面的读操作与volatile读操作发生指令重排。
- 在每个volatile读操作的后面插入一个LoadStore屏障，保证后面的其他写操作的无效化队列已经将volatile无效刷新到缓存中，防止后面的写操作与volatile读操作发生指令重排。

![image-20200711071715570](F:\MyBlog\gpf951101.GitHub.io\images\image-20200711071715570.png)

## 1.3 volatile在单例模式中的应用

```java
public class SingletonDemo {
    
    private static volatile SingletonDemo intance = null;
    private SingletonDemo() {}
    
    /**
    * 双重检测机制DCL
    *
    */
    public static SingletonDemo getInstance() {
        if(instance==null) {
            synchronized(SingletonDemo.class) {
                if(instance==null) {
                    instance = new SingletonDemo();
                }
            }
        }
        return instance;
    }
}
```

DCL 机制不一定线程安全，原因是有指令重排的存在，加入volatile之后可以禁止指令重排。

`instance = new SingletonDemo();`可分为一下步骤：

1. 分配对象的内存空间
2. 初始化对象
3. 设置instance指向刚刚分配的内存地址，此时instance!=null

步骤2和步骤3不存在数据依赖，可能会有指令重排发生，如果执行顺序为1-3-2，执行3之后，另外的线程进行实例化，但是此时instance并没有初始化完成，宠儿造成线程的安全性问题。

# 2. CAS的缺点

CAS：Cpmpare and Swap 比较并交换

缺点：

1. CAS类似于自旋锁，如果失败，一直执行，导致开销很大。
2. 只能保证一个共享变量的原子性——用锁解决
3. 导致ABA问题

# 3. 对ABA问题的理解

CAS会导致ABA问题。

CAS算法实现的一个重要前提需要去除内存中某时刻的数据并在当下时刻比较替换，那么这个时间差类会导致数据的变化。

如果一个线程A从内存位置V取出a，这是另一个线程B也从内存取出a，并且B操作把值变为b，之后又把位置V的值变为了a，A线程进行CAS操作之后发现值仍为a，线程A操作成功，但是其实这时候的a已经不是最开始的a。

## 解决办法

时间戳原子引用。

原子引用：AtomicReference可以添加泛型，调用`conpareAndSet`方法，实现CAS操作。

时间戳原子引用：AtomicStampedReference，该类雷同与AtomicReference，但是`compareAndSet`方法的参数比AtomicReference多了一个版本号，可通过版本号判断当前的值和之前是否一样。

```java
//AtomicStampedReference
public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) 
```

# 4. ArrayList是否是线程安全的？写出案例并给出解决方案

线程不安全案例：

```java
package JUC;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class ArrayListTest {
    public static void main(String[] args) {

        List<String> list=new ArrayList();
        for (int i=0;i<30;i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(8));  
                System.out.println(list);
            }).start();
        }
    }
}
```

运行结果：

```bash
java.util.ConcurrentModificationException
```

ArrayList add源码：

```java
private int size;
……
public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
```

size++是线程不安全的。

还有可能造成数组越界：

```bash
Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 499, Size: 499
```

原因：

add元素时，实际做了两个大的步骤：

- 判断elementData数组容量是否满足需求
- 在elementData对应位置上设置值

这样也就出现了第一个导致线程不安全的隐患，在多个线程进行add操作时可能会导致elementData数组越界。具体逻辑如下：

- 列表大小为9，即size=9
- 线程A开始进入add方法，这时它获取到size的值为9，调用ensureCapacityInternal方法进行容量判断。
- 线程B此时也进入add方法，它获取到size的值也为9，也开始调用ensureCapacityInternal方法。
- 线程A发现需求大小为10，而elementData的大小就为10，可以容纳。于是它不再扩容，返回。
- 线程B也发现需求大小为10，也可以容纳，返回。
- 线程A开始进行设置值操作， elementData[size++] = e 操作。此时size变为10。
- 线程B也开始进行设置值操作，它尝试设置elementData[10] = e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException.

```java
package JUC;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class ArrayListTest {
    // ArrayList
    protected static ArrayList<Object> arrayList = new ArrayList<Object>();
    // 解决措施①：使用Vector集合
    protected static Vector<Object> arrayListSafe1 = new Vector<Object>();
    // 解决措施②：我们加上Collections.synchronizedList，它会自动将我们的list方法进行改变，最后返回给我们一个加锁了List
    static List<Object> arrayListSafe2 = Collections.synchronizedList(new ArrayList<Object>());
    // 解决措施3：CopyOnWrite
    static List<Object> arrayListSafe3 = new CopyOnWriteArrayList<Object>();
    
    public static void main(String[] args) {
        Thread[] threads = new Thread[500];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new ArrayListThread();
            threads[i].start();
        }
        for (int i = 0; i < threads.length; i++) {
            try {
                threads[i].join();// 等待该线程终止
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 输出list中的对象元素
        for (int i = 0; i < threads.length; i++) {
            System.out.println(arrayList.get(i));
        }
    }
}
class ArrayListThread extends Thread {
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        ArrayListTest.arrayList.add(Thread.currentThread().getName());
    }
}
```

解决办法：

1. **vector**

*Vector类* 是可以实现自动增长的对象数组，其add操作是用synchronized关键字修饰的，从而保证了add方法的线程安全。保证了数据的一致性，但由于加锁导致访问性能大大降低。

```
public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
```

2. **使用Collections工具类**

用Collections工具类将线程不安全的ArrayList类转换为线程安全的集合类。小体量数据的ArrayList类可以使用这种方法创建线程安全的类。

底层方法大多用`synchronized`修饰

```java
//Collections->SynchronizedCollection
public int size() synchronized (mutex) {return c.size();}
public boolean isEmpty() synchronized (mutex) {return c.isEmpty();}
public boolean contains(Object o) synchronized (mutex) {return c.contains(o);}
public Object[] toArray() synchronized (mutex) {return c.toArray();}
public <T> T[] toArray(T[] a) synchronized (mutex) {return c.toArray(a);}
```

3. **使用CopyOnWriteArrayList类**

CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

```java
//CopyOnWriteArrayList
public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
```

同理，JUC中有`hashset`的安全实现`CopyOnWriteHashSet`和hashMap的安全实现`CopyOnWriteHashMap`。

# 5. 谈谈对锁的理解

- 公平锁/非公平锁
- 可重入锁
- 独享锁/共享锁
- 互斥锁/读写锁
- 乐观锁/悲观锁
- 分段锁
- 偏向锁/轻量级锁/重量级锁
- 自旋锁

## 5.1 公平锁与非公平锁

**公平锁**：指多个线程按照申请锁的顺序来获取锁，类似于排队打饭，先来后到。

**非公平锁**：指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

并发包`ReentrantLock`的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁。

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

对于`Synchronized`而言，也是一种非公平锁。由于其并不像`ReentrantLock`是通过`AQS(AbstractQueuedSynchronizer)`的来实现线程调度，所以并没有任何办法使其变成公平锁。

非公平锁的优点在于吞吐量比公平锁大.

## 5.2 可重入锁(递归锁)

指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。也就是说 **线程可以进入任何一个它已经拥有的锁锁同步着的代码块**。

对于`ReentrantLock`而言, 他的名字就可以看出是一个可重入锁，其名字是`Re` `entrant` `Lock`重新进入锁。

对于`Synchronized`而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。

```java
class Phone{
    public synchronized void sendSms() throws Exception{
        System.out.println(Thread.currentThread().getName()+"\tsendSms");
        sendEmail();
    }
    public synchronized void sendEmail() throws Exception{
        System.out.println(Thread.currentThread().getName()+"\tsendEmail");
    }
}
public static void main(String[] args) {
        Phone phone = new Phone();
        new Thread(()->{
            try {
                phone.sendSms();
            } catch (Exception e) {
                e.printStackTrace();
            }
        },"t1").start();
        new Thread(()->{
            try {
                phone.sendSms();
            } catch (Exception e) {
                e.printStackTrace();
            }
        },"t2").start();
    }

```

如果不是可重入锁，可能导致`sendSms()`执行`sendEmail()`造成死锁。

## 5.3 独享锁与共享锁

- 独享锁：指该锁一次只能被一个线程锁持有
- 共享锁：该锁可被多个线程所持有

对`ReentrantLock`和`Synchronized`而言都是独占锁，`ReadWriteLock`而言，读锁是共享锁，写锁是独占锁，读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程都是互斥的。

独享所和共享锁也是通过`AQS(AbstractQueuedSynchronizer)`实现的。

## 5.4 互斥锁与读写锁

独享锁/共享锁是一种广义上的概念,而互斥锁/读写锁就是其具体的实现案例。

- 互斥锁的具体实现就是`ReentrantLock`
- 读写锁的具体实现就是`ReadWriteLock`

**使用读写锁实现缓存**

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author admin
 * @Description
 * @create 2020-06-24 22:16
 */

class MyChace {
    private volatile Map<String, Object> map = new HashMap<>();
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    public void put(String key, Object value) {
        lock.writeLock().lock();
        try{
            System.out.println(Thread.currentThread().getName()+"\t 准备写入数据。。。");
            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            map.put(key, value);
            System.out.println(Thread.currentThread().getName()+"\t 写入数据成功");
        } catch (Exception e){
            e.printStackTrace();
        } finally {
            lock.writeLock().unlock();
        }
    }
    public Object get(String key) {
        Object o = null;
        lock.readLock().lock();
        try{
            System.out.println(Thread.currentThread().getName()+"\t 准备读取数据。。。");
            try {
                TimeUnit.MILLISECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            o = map.get(key);
            System.out.println(Thread.currentThread().getName()+"\t 读取数据成功 \t" + o.toString());
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.readLock().unlock();
        }
        return o;
    }
}
public class ReadWriteLock {
    public static void main(String[] args) {
        MyChace myChace = new MyChace();
        for (int i = 0; i < 5; i++) {
            String tmp = String.valueOf(i);
            new Thread(() -> {
                myChace.put(tmp,  tmp);
            }, tmp).start();
        }

        for (int i = 0; i < 5; i++) {
            String tmp = String.valueOf(i);
            new Thread(() -> {
                Object o = myChace.get(tmp);
            }, tmp).start();
        }
    }
}

```

## 5.5 乐观锁与悲观锁

乐观锁/悲观锁不是指代具体的锁类型,其是以看待并发的角度划分的。

- 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
- 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
 悲观锁在Java中的使用，就是利用各种锁。
 乐观锁在Java中的使用，是无锁编程，常常采用的是**CAS**算法，典型的例子就是**原子类**，通过**CAS自旋**实现原子操作的更新

## 5.6 分段锁

分段锁其实是一种锁的设计，并不是具体的一种锁，对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

我们以`ConcurrentHashMap`来说一下分段锁的含义以及设计思想，`ConcurrentHashMap`中的分段锁称为`Segment`，它即类似于`HashMap`（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个`ReentrantLock`（Segment继承了ReentrantLock)。

当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。

但是，在统计size的时候，就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

## 5.7 偏向锁/轻量级锁/重量级锁

这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

- **偏向锁**是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- **轻量级锁**是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- **重量级锁**是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

## 5.8 自旋锁

**自旋锁**：指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

手写自旋锁代码：

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author admin
 * @Description
 * @create 2020-06-23 17:52
 */
public class SpinLock {
    AtomicReference<Thread> atomicReference = new AtomicReference<>();
    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName()+"\t 我准备进来了");
        while(!atomicReference.compareAndSet(null, thread)){

        }
        System.out.println(thread.getName()+"\t 我进来了");
    }
    public void myUnlock(){
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName()+"\t 我准备出去了");
        atomicReference.compareAndSet(thread, null);
        System.out.println(thread.getName()+"\t 我出去了");
    }
    public static void main(String[] args) {
        SpinLock spinLock = new SpinLock();
        new Thread(() -> {
            spinLock.myLock();
            System.out.println(Thread.currentThread().getName()+"\t 正在占用。。。");
            try { TimeUnit.SECONDS.sleep(5);} catch (InterruptedException e) { e.printStackTrace();}
            spinLock.myUnlock();
        }, "t1").start();

        new Thread(() -> {
            spinLock.myLock();
            System.out.println(Thread.currentThread().getName()+"\t 正在占用。。。");
            spinLock.myUnlock();
        }, "t2").start();

    }
}
/**
 * t1	 我准备进来了
 * t1	 我进来了
 * t2	 我准备进来了 // 正在等待t1结束，正在while循环
 * t1	 正在占用。。。
 * t1	 我准备出去了
 * t1	 我出去了
 * t2	 我进来了
 * t2	 正在占用。。。
 * t2	 我准备出去了
 * t2	 我出去了
 */
```

# 6. AQS中的 CountdownLatch、CyclicBarrier、 Semaphore

AQS(AbstractQueuedSynchronizer)的**核心思想**：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。

## 6.1 CountDownLatch

用来控制一个线程等待多个线程。

维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

![img](F:\MyBlog\gpf951101.GitHub.io\images\70)

demo:

```java
import java.util.concurrent.CountDownLatch;

/**
 * @author admin
 * @Description
 * @create 2020-06-24 23:00
 */
enum Seasons {
    ONE(1, "春"), TWO(2, "夏"), THREE(3, "秋"), FOUR(4, "冬");
    Seasons(Integer id, String msg) {
        this.id = id;
        this.msg = msg;
    }
    private Integer id;
    private String msg;
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getMsg() {
        return msg;
    }
    public void setMsg(String msg) {
        this.msg = msg;
    }
    static Seasons forEach(int index) {
        Seasons[] values = Seasons.values();
        for (Seasons s: values) {
            if(s.getId() == index) {
                return s;
            }
        }
        return null;
    }
}
public class CountDownLatchDemo {

    public static void main(String[] args) {

        CountDownLatchDemo countDownLatchDemo = new CountDownLatchDemo();
        countDownLatchDemo.closeDoor();
    }
    void closeDoor() {
        CountDownLatch countDownLatch = new CountDownLatch(4);

        for (int i = 1; i <= 4; i++) {

            new Thread(() -> {
                System.out.println(Thread.currentThread().getName());
                countDownLatch.countDown();
            }, Seasons.forEach(i).getMsg()).start();
        }
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "\t 一年四季");
    }
}
/**
 * 春
 * 夏
 * 秋
 * 冬
 * main	 一年四季
 */
```

## 6.2 CyclicBarrier

用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

和 CountdownLatch 相似，都是通过维护计数器来实现的。但是它的计数器是递增的，每次执行 await() 方法之后，计数器会加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。和 CountdownLatch 的另一个区别是，CyclicBarrier 的计数器可以循环使用，所以它才叫做循环屏障。

![image-20200711123346402](F:\MyBlog\gpf951101.GitHub.io\images\image-20200711123346402.png)

demo:

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @author admin
 * @Description
 * @create 2020-06-24 23:30
 * 0号	 运动员入场
 * 1号	 运动员入场
 * 2号	 运动员入场
 * 3号	 运动员入场
 * 4号	 运动员入场
 * 5号	 运动员入场
 * 6号	 运动员入场
 * Begin! Go! Go! GO!
 * 6号	 等待结束
 * 0号	 等待结束
 * 1号	 等待结束
 * 2号	 等待结束
 * 3号	 等待结束
 * 5号	 等待结束
 * 4号	 等待结束
 */
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {System.out.println("Begin! Go! Go! GO!");});

        for (int i = 0; i < 7; i++) {
            String tmp = i + "";
            new Thread(() -> {
                System.out.println(tmp+"号\t 运动员入场");
                try {
                    cyclicBarrier.await();
                    System.out.println(tmp+"号\t 等待结束");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }

            }, String.valueOf(i)).start();
        }
    }
}

```



## 6.3 Semaphore

Semaphore 就是操作系统中的信号量，可以控制对互斥资源的访问线程数。

![img](F:\MyBlog\gpf951101.GitHub.io\images\semaphore.png)

demo

```java
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * @author admin
 * @Description
 * @create 2020-06-24 23:42
 * 0	 获得车位
 * 1	 获得车位
 * 2	 获得车位
 * 1	 停车3秒后离开
 * 0	 停车3秒后离开
 * ==========
 * 2	 停车3秒后离开
 * ==========
 * 当前剩余车位：	1
 * 3	 获得车位
 * 4	 获得车位
 * ==========
 * 当前剩余车位：	0
 * 5	 获得车位
 * 当前剩余车位：	0
 * 5	 停车3秒后离开
 * ==========
 * 当前剩余车位：	1
 * 3	 停车3秒后离开
 * ==========
 * 当前剩余车位：	2
 * 4	 停车3秒后离开
 * ==========
 * 当前剩余车位：	3
 */
public class SemaphoreDemo {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire(); // 抢占 资源重用
                    System.out.println(Thread.currentThread().getName()+"\t 获得车位");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println(Thread.currentThread().getName()+"\t 停车3秒后离开");

                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release(); //释放资源
                    System.out.println("==========");
                    System.out.println("当前剩余车位：\t"+semaphore.availablePermits());
                }

            }, String.valueOf(i)).start();
        }
    }
}

```

**[AQS参考](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)**

# 7. 阻塞队列

阻塞队列(BlockingQueue)也是一种队列，阻塞队列在Java中的一种典型的使用场景是线程池，在线程池中，当提交的任务不能被立即得到执行，线程池就会将提交的任务放到一个阻塞队列中。

常见的两种场景：

1) 当队列中没有数据，消费者线程自动阻塞，知道有数据。

![image-20200712214129434](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712214129434.png)

2) 当队列中数据填满，生产者线程自动阻塞，知道队列中有空间。

![image-20200712214411837](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712214411837.png)

使用BlockingQueue之后不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，BlockingQueue自动操作。而此前需要程序员自己去控制细节，尤其还要兼顾效率和线程安全。

## 7.1 BlockingQueue的核心方法

![image-20200712214736977](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712214736977.png)

**抛出异常**: 当阻塞队列满时,再往队列里面add插入元素会抛IllegalStateException: Queue full 

​				当阻塞队列空时,再往队列Remove元素时候回抛出NoSuchElementException
**特殊值** : 插入方法,成功返回true ;失败返回false
​				移除方法,成功返回元素;队列里面没有就返回null
**一直阻塞**: 当阻塞队列满时,生产者继续往队列里面put元素,队列会一直阻塞直到put数据or响应中断退出
​				当阻塞队列空时,消费者试图从队列take元素,队列会一直阻塞消费者线程直到队列可用.
**超时退出** :当阻塞队列满时,队列会阻塞生产者线程一定时间,超过后限时后生产者线程就会退出

## 7.2 BlockingQueue的实现类

![image-20200712215534592](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712215534592.png)

- PriorityBlockingQueue:支持优先级排序的**无界**阻塞队列. 基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。

- DelayQueue: 只有当其指定的延迟时间到了，才能够从队列中获取到该元素,DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。

- LinkedTransferQueue:由链表结构组成的**无界**阻塞队列.

- LinkedBlockingDeque:由链表结构组成的**双向**阻塞队列.

- **ArrayBlockingQueue**: 由数组结构组成的有界阻塞队列.在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行

- **LinkedBlockingQueue**: 由链表结构组成的有界(但大小默认值Integer>MAX_VALUE)阻塞队列.其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

- **SynchronousQueue**:不存储元素的阻塞队列,也即是单个元素的队列.每个put操作必须要等待一个take操作,否则不能继续添加元素,反之亦然.

  - Demo

  - ```java
    import java.util.concurrent.BlockingQueue;
    import java.util.concurrent.SynchronousQueue;
    import java.util.concurrent.TimeUnit;
    
    /**
     * @author admin
     * @Description
     * @create 2020-06-25 23:57
     * BBB	 put 1
     * AAA	 get 1
     * BBB	 put 2
     * AAA	 get 2
     * BBB	 put 3
     * AAA	 get 3
     */
    public class SynchronousQueueDemo {
    
        public static void main(String[] args) {
            BlockingQueue<String> blockingQueue = new SynchronousQueue<>();
    
    
            new Thread(() -> {
    
                try {
                    TimeUnit.SECONDS.sleep(5);
                    System.out.println(Thread.currentThread().getName()+"\t get " + blockingQueue.take());
    
                    TimeUnit.SECONDS.sleep(5);
                    System.out.println(Thread.currentThread().getName()+"\t get " + blockingQueue.take());
    
                    TimeUnit.SECONDS.sleep(5);
                    System.out.println(Thread.currentThread().getName()+"\t get " + blockingQueue.take());
    //                System.out.println(Thread.currentThread().getName()+"\t get " + blockingQueue.take());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "AAA").start();
            
            new Thread(() -> {
    
                try {
                    System.out.println(Thread.currentThread().getName()+"\t put 1");
                    blockingQueue.put("1");
    
                    System.out.println(Thread.currentThread().getName()+"\t put 2");
                    blockingQueue.put("2");
    
                    System.out.println(Thread.currentThread().getName()+"\t put 3");
                    blockingQueue.put("3");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "BBB").start();
        }
    }
    ```

# 8. Synchronized和Lock的区别

1. 原始构成上来看，**Synchorized**是关键字，属于JVM层面；**Lock**是具体类（java.util.concurrent.Locks.Lock）是API层面的锁。

2. 使用方法上来看，**Synchorized**不需要用户手动释放锁，执行完毕后系统会自动让线程释放对锁的占用，**Lock**需要用户手动去释放锁，如没有主动释放锁，则可能出现死锁现象，使用`try……finally`.在finally中释放。使用lock()和unlock()方法。

3. 等待是否可中断：**Synchorized**不可中断，除非抛出异常或者正常运行完成。**Lock**可中断：1）设置超时方法`tryLock(long timeout, TimeUnit unit)` 2）lockInterruptibly()放代码块中，调用interrupt()方法可中断

4. 锁是否公平：**Synchorized**非公平锁，**Lock**都可以，默认是非公平锁。

5. 绑定多个条件Condition：**Synchorized**不可以，**Lock**可实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是想Synchronized随机或者唤醒全部。

   - 使用await()方法等待，signal()唤醒

   - demo

   - ```java
     import java.util.concurrent.locks.Condition;
     import java.util.concurrent.locks.Lock;
     import java.util.concurrent.locks.ReentrantLock;
     
     /**
      * @author admin
      * @Description
      * @create 2020-06-27 23:52
      *
      * A 打印5次
      * B 打印10次
      * C 打印15次
      *
      * 循环上述2次 按照顺序
      * 
      * A	0-A	1-A	2-A	3-A	4-
      * B	0-B	1-B	2-B	3-B	4-B	5-B	6-B	7-B	8-B	9-
      * C	0-C	1-C	2-C	3-C	4-C	5-C	6-C	7-C	8-C	9-C	10-C	11-C	12-C	13-C	14-
      * A	0-A	1-A	2-A	3-A	4-
      * B	0-B	1-B	2-B	3-B	4-B	5-B	6-B	7-B	8-B	9-
      * C	0-C	1-C	2-C	3-C	4-C	5-C	6-C	7-C	8-C	9-C	10-C	11-C	12-C	13-C	14-
      */
     
     class DataResource {
         private int number = 0; // 0-A 1-B 2-C
         private Lock lock = new ReentrantLock();
         private Condition conditions [] = {lock.newCondition(), lock.newCondition(), lock.newCondition()};
     
         public void printNum(int num, int flag) {
             lock.lock();
             try {
                 // 1 判断
                 while(number != flag) {
                     conditions[flag].await();
                 }
                 // 2 干活
                 for (int i = 0; i < num; i++) {
                     System.out.print(Thread.currentThread().getName()+"\t"+i + "-");
                 }
                 System.out.println();
                 // 3 通知
                 number = (number+1)%3;
                 conditions[(flag+1)%3].signal();
     
             } catch (Exception e) {
                 e.printStackTrace();
             } finally {
                 lock.unlock();
             }
         }
     }
     
     public class ConditionDemo {
     
         public static void main(String[] args) {
             DataResource DataResource = new DataResource();
     
             new Thread(() -> {
                 for (int i = 0; i < 2; i++) {
                     DataResource.printNum(5, 0);
                 }
             }, "A").start();
             new Thread(() -> {
                 for (int i = 0; i < 2; i++) {
                     DataResource.printNum(10, 1);
                 }
             }, "B").start();
             new Thread(() -> {
                 for (int i = 0; i < 2; i++) {
                     DataResource.printNum(15, 2);
                 }
             }, "C").start();
     
         }
     }
     
     ```

   

6. 锁状态的判断：**Synchorized**无法判断，**Lock**可判断。

# 9. 阻塞队列的使用

1. 生产者消费者模式

   - demo

   - 传统的：

   - ```java
     import java.util.concurrent.locks.Condition;
     import java.util.concurrent.locks.Lock;
     import java.util.concurrent.locks.ReentrantLock;
     
     /**
      * @author admin
      * @Description
      * @create 2020-06-27 23:14
      * AA	1
      * bb	0
      * cc	1
      * bb	0
      * cc	1
      * dd	0
      * AA	1
      * dd	0
      */
     
     class ShareData {
     
         private int number = 0;
         private Lock lock = new ReentrantLock();
         private Condition condition = lock.newCondition();
     
         public void increment() {
             lock.lock();
             try {
                 // 1 判断 必须使用while， 当有多个线程操作，可能需要de的通知，但是却收到in的通知
                 while(number != 0) {
                     condition.await();
                 }
                 // 2 干活
                 number++;
                 System.out.println(Thread.currentThread().getName()+"\t"+number);
                 // 3 通知
                 condition.signalAll();
             } catch (Exception e) {
                 e.printStackTrace();
             } finally {
                 lock.unlock();
             }
     
         }
     
         public void decrement() {
             lock.lock();
             try {
                 // 1 判断 必须使用while， 当有多个线程操作，可能需要de的通知，但是却收到in的通知
                 while(number == 0) {
                     condition.await();
                 }
                 // 2 干活
                 number--;
                 System.out.println(Thread.currentThread().getName()+"\t"+number);
                 // 3 通知
                 condition.signalAll();
             } catch (Exception e) {
                 e.printStackTrace();
             } finally {
                 lock.unlock();
             }
         }
     }
     
     public class producerConsumer_TraditionalDemo {
     
         public static void main(String[] args) {
             ShareData shareData = new ShareData();
     
             new Thread(() -> {
                 for (int i = 0; i < 2; i++) {
                     shareData.increment();
                 }
             }, "AA").start();
     
             new Thread(() -> {
                 for (int i = 0; i < 2; i++) {
                     shareData.decrement();
                 }
             }, "bb").start();
     
             new Thread(() -> {
                 for (int i = 0; i < 2; i++) {
                     shareData.increment();
                 }
             }, "cc").start();
     
             new Thread(() -> {
                 for (int i = 0; i < 2; i++) {
                     shareData.decrement();
                 }
             }, "dd").start();
         }
     }
     
     ```

   - BlockingQueue

   - ```java
     import java.util.concurrent.ArrayBlockingQueue;
     import java.util.concurrent.BlockingQueue;
     import java.util.concurrent.TimeUnit;
     import java.util.concurrent.atomic.AtomicInteger;
     
     /**
      * @author admin
      * @Description
      * @create 2020-06-29 23:36
      *
      * volatile/BlockQueue/AtomicInteger
      *
      * 传入的类为：java.util.concurrent.ArrayBlockingQueue
      * 生产者线程启动++++++
      * producer	 进入生产者线程
      * ++++++++++++++++++++++++++
      * 消费者线程启动++++++
      * consumer	 进入消费者线程
      * producer	生产1成功
      * ——————————————————————————————————
      * consumer	消费1
      * producer	生产2成功
      * consumer	消费2
      * producer	生产3成功
      * consumer	消费3
      * consumer	消费4
      * producer	生产4成功
      * producer	生产5成功
      * consumer	消费5
      * 停止！！！！！！！！！
      * producer	生产者线程停止！
      * ===============================
      */
     
     
     class MyResource {
         private volatile boolean FLAG = true;
         private AtomicInteger atomicInteger = new AtomicInteger();
         private BlockingQueue<String> blockingQueue = null;
     
         public MyResource(BlockingQueue<String> blockingQueue) {
             this.blockingQueue = blockingQueue;
             System.out.println("传入的类为：" + blockingQueue.getClass().getName());
         }
     
         public void myProducer() throws Exception {
             System.out.println(Thread.currentThread().getName()+"\t 进入生产者线程");
             System.out.println("++++++++++++++++++++++++++");
             String data = null;
             boolean returnVal = false;
     
             while(FLAG) {
                 data = atomicInteger.incrementAndGet()+"";
                 returnVal = blockingQueue.offer(data,2L, TimeUnit.SECONDS);
                 if(returnVal)
                     System.out.println(Thread.currentThread().getName()+"\t生产"+ data + "成功");
                 else
                     System.out.println(Thread.currentThread().getName()+"\t生产"+ data + "失败！！！！！！！");
     
                 TimeUnit.SECONDS.sleep(1L);
     
             }
             System.out.println(Thread.currentThread().getName()+"\t生产者线程停止！");
             System.out.println("===============================");
         }
     
         public void myConsumer() throws Exception {
             System.out.println(Thread.currentThread().getName()+"\t 进入消费者线程");
             System.out.println("——————————————————————————————————");
             String result = null;
             while(FLAG) {
     
                 result = blockingQueue.poll(2L, TimeUnit.SECONDS);
                 // 被动停止线程，因队列中没有值
                 if(result == null || result.equalsIgnoreCase("")){
                     FLAG = false;
                     System.out.println(Thread.currentThread().getName()+"\t超过2秒没有取到值，退出！！！");
                     System.out.println("==============================================");
                     return;
                 }
                 System.out.println(Thread.currentThread().getName()+"\t消费"+ result);
                 TimeUnit.SECONDS.sleep(1L);
             }
         }
     
         public void stop() throws Exception {
             //主动停止线程
             FLAG = false;
         }
     }
     
     public class ProducerConsumer_BlockQueueDemo {
     
         public static void main(String[] args){
             MyResource myResource = new MyResource(new ArrayBlockingQueue<String>(2));
     
             new Thread(() -> {
                 System.out.println("生产者线程启动++++++");
                 try {
                     myResource.myProducer();
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
             }, "producer").start();
     
             new Thread(() -> {
                 System.out.println("消费者线程启动++++++");
                 try {
                     myResource.myConsumer();
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
             }, "consumer").start();
     
             try {
                 TimeUnit.SECONDS.sleep(5);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
     //
             try {
                 myResource.stop();
             } catch (Exception e) {
                 e.printStackTrace();
             }
             System.out.println("停止！！！！！！！！！");
         }
     }
     
     ```

     

2. 线程池

3. 消息中间件

# 10. 线程的创建方法

1.  继承Thread类，重写run方法

   demo

   ```java
   class Thread1 extends Thread {
       /**
        * 继承Thread，复写run方法
        */
       public Thread1(String name) {
           super();
           this.setName(name);
       }
   
       public void run() {
           System.out.println(Thread.currentThread().getName()+"\t thread1 run");
       }
   }
   // 使用
   new Thread1("1").start();
   ```

2.  实现Runnable接口

   demo

   ```java
   class Thread2 implements Runnable {
   
       @Override
       public void run() {
           System.out.println(Thread.currentThread().getName()+"\t thread2 run");
       }
   }
   // 使用
   new Thread(new Thread2(), "2").start();
   ```

3. 实现Callable接口通过FutureTask来包装

   demo

   ```java
   class Thread3 implements Callable<Integer> {
       /**
        * 有返回值
        * @return
        * @throws Exception
        */
       @Override
       public Integer call() throws Exception {
           System.out.println(Thread.currentThread().getName()+"\t thread3 run");
           return 3;
       }
   }
   // 使用
   // 3
   Callable<Integer> callable = new Thread3();
   FutureTask<Integer> futureTask = new FutureTask<>(callable);
   new Thread(futureTask, "3").start();
   System.out.println(futureTask.get()); // 通过get获取返回值
   ```

4. 线程池

   demo

   ```java
    // 4 线程池
   //        ExecutorService threadPool = Executors.newFixedThreadPool(5); // 一个线程池5个处理线程
   //        ExecutorService threadPool = Executors.newSingleThreadExecutor(); // 一个线程池1个处理线程
   //        ExecutorService threadPool = Executors.newCachedThreadPool(); // 一个线程池N个处理线程
   
   
           // 4.1 手写线程池
           ExecutorService threadPool = new ThreadPoolExecutor(
                   2,
                   10,
                   1L,
                   TimeUnit.SECONDS,
                   new LinkedBlockingDeque<>(1),
                   Executors.defaultThreadFactory(),
   //                new ThreadPoolExecutor.AbortPolicy() //默认策略——报错
   //                new ThreadPoolExecutor.CallerRunsPolicy() // 回退给调用者
   //                new ThreadPoolExecutor.DiscardOldestPolicy() // 丢弃等待时间最久的
                   new ThreadPoolExecutor.DiscardPolicy() // 丢弃 满了之后丢弃
                   );
   
           try {
               for (int i = 0; i < 15; i++) {
                   final int tmp = i;
                   threadPool.execute(() -> {
                       System.out.println(tmp + "\t" + Thread.currentThread().getName()+"\t 办理业务");
                       try {
                           TimeUnit.SECONDS.sleep(1);
                       } catch (InterruptedException e) {
                           e.printStackTrace();
                       }
                   });
               }
           } catch (Exception e) {
               e.printStackTrace();
           } finally {
               threadPool.shutdown();
           }
   ```

   ## 线程池

   线程池做的工作主要是控制运行的线程的数量,处理过程中将任务加入队列,然后在线程创建后启动这些任务,如果先生超过了最大数量,超出的数量的线程排队等候,等其他线程执行完毕,再从队列中取出任务来执行.

   他的主要特点为:线程复用:控制最大并发数:管理线程.

   ### 1. 线程池的优势

   - 降低资源消耗.通过重复利用自己创建的线程降低线程创建和销毁造成的消耗.
   - 提高响应速度.当任务到达时,任务可以不需要等到线程创建就能立即执行.
   - 提高线程的可管理性.线程是稀缺资源,如果无限的创建,不仅会消耗资源,还会降低系统的稳定性,使用线程池可以进行统一分配,调优和监控.

   ### 2. 架构实现

   通过`Executor`实现。

   ![image-20200712225718348](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712225718348.png)

   #### 2.1 ExecutorService threadPool = Executors.newFixedThreadPool(5); // 一个线程池5个处理线程

   ```java
   public static ExecutorService newFixedThreadPool(int nThreads) {
           return new ThreadPoolExecutor(nThreads, nThreads,
                                         0L, TimeUnit.MILLISECONDS,
                                         new LinkedBlockingQueue<Runnable>());
       }
   ```

   主要特点如下:
    	1. 创建一个定长线程池,可控制线程的最大并发数,超出的线程会在队列中等待.
    	2. newFixedThreadPool创建的线程池corePoolSize和MaxmumPoolSize是 相等的,它使用的的LinkedBlockingQueue
    	3. 执行一个长期的任务，性能好很多。

   #### 2.2 Executors.newSingleThreadExecutor(); // 一个线程池1个处理线程

   ```java
   @NotNull public static ExecutorService newSingleThreadExecutor() {
           return new FinalizableDelegatedExecutorService
               (new ThreadPoolExecutor(1, 1,
                                       0L, TimeUnit.MILLISECONDS,
                                       new LinkedBlockingQueue<Runnable>()));
       }
   ```

   主要特点如下:

   1. 创建一个单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务都**按照指定顺序执行**.
   2. newSingleThreadExecutor将corePoolSize和MaxmumPoolSize都设置为1,它使用的的LinkedBlockingQueue
   3. 适用于一个任务一个线程执行的场景。

   #### 2.3 Executors.newCachedThreadPool(); // 一个线程池N个处理线程

   ```java
   @NotNull public static ExecutorService newCachedThreadPool() {
           return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                         60L, TimeUnit.SECONDS,
                                         new SynchronousQueue<Runnable>());
       }
   ```

   主要特点如下:

   1. 创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则创建新线程.
   2. newCachedThreadPool将corePoolSize设置为0,MaxmumPoolSize设置为Integer.MAX_VALUE,它使用的是SynchronousQueue,也就是说来了任务就创建线程运行,如果线程空闲超过60秒,就销毁线程
   3. 适用于执行很多短期异步的小程序或者负载较轻的服务

   ### 3. 线程池7大参数

   ```java
   public ThreadPoolExecutor(int corePoolSize,
                                 int maximumPoolSize,
                                 long keepAliveTime,
                                 TimeUnit unit,
                                 BlockingQueue<Runnable> workQueue,
                                 ThreadFactory threadFactory,
                                 RejectedExecutionHandler handler)
   ```

   ![image-20200712230800121](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712230800121.png)

   ### 4. 线程池工作原理

   ![image-20200712231001590](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712231001590.png)

   ![image-20200712231212992](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712231212992.png)

   ### 5. 线程池参数设置

   CPU密集型：查看CPU核数，一般：CPU核数+1个线程的线程池

   IO密集型：大部分线程都阻塞，公式：CPU核数/(1-阻塞系数), 阻塞系数为0.8~0.9.

# 11. 死锁

## 11.1 死锁是什么

![image-20200712231711173](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712231711173.png)

产生原因：

- 系统资源不足
- 进程运行推进的顺序不合适
- 资源分配不当

## 11.2 死锁代码

```java
package JUC;

import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author admin
 * @Description
 * @create 2020-07-10 15:30
 */

class HoldLock implements Runnable{

    private String lockA;
    private String lockB;

    public HoldLock(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized(lockA) {
            System.out.println(Thread.currentThread().getName()+"\t 持有" + lockA +", 尝试获取" + lockB);
            try {
                TimeUnit.SECONDS.sleep(1L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized(lockB) {
                System.out.println(Thread.currentThread().getName()+"\t 持有" + lockB +", 尝试获取" + lockA);
            }
        }
    }
}


public class DeadLockDemo {


    public static void main(String[] args) {

        String lockA = "lockAA";
        String lockB = "lockBB";

        new Thread(new HoldLock(lockA, lockB), "AAA").start();
        new Thread(new HoldLock(lockB, lockA), "BBB").start();
    }
}

```

## 11.3 死锁的解决

1. jps命令定位进程编号（jsp: java ps）

   ![image-20200712232057639](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712232057639.png)

2. jstack 编号 找到死锁查看

![image-20200712232252989](F:\MyBlog\gpf951101.GitHub.io\images\image-20200712232252989.png)

# 参考资料

1. [Java中对锁的理解](https://www.jianshu.com/p/a2193eda8d26)
2. [AQS中的 CountdownLatch、CyclicBarrier、 Semaphore](https://blog.csdn.net/qq_32256003/article/details/81604326)
3. [BlockingQueue](https://developer.aliyun.com/article/341999)
4. [尚硅谷视频](https://www.bilibili.com/video/BV1zb411M7NQ)